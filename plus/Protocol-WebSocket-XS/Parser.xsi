MODULE = Protocol::WebSocket::XS                PACKAGE = Protocol::WebSocket::XS::Parser
PROTOTYPES: DISABLE

size_t Parser::max_frame_size (SV* newval = NULL) {
    if (newval) THIS->max_frame_size = SvUV(newval);
    RETVAL = THIS->max_frame_size;
}

size_t Parser::max_message_size (SV* newval = NULL) {
    if (newval) THIS->max_message_size = SvUV(newval);
    RETVAL = THIS->max_message_size;
}

bool Parser::established ()

bool Parser::recv_closed ()

bool Parser::send_closed ()

void Parser::get_frames (string buf = string()) {
    auto frames = buf ? THIS->get_frames(buf) : THIS->get_frames();
    if (GIMME_V == G_ARRAY) for (auto frame : frames) mXPUSHs(xs::out(frame).detach());
    else {
        if (frames.begin() == frames.end()) XSRETURN_UNDEF;
        auto itsv = xs::out(new XSFrameIterator(frames.begin()));
        mPUSHs(itsv.detach());
    }
}

void Parser::get_messages (string buf = string()) {
    auto messages = buf ? THIS->get_messages(buf) : THIS->get_messages();
    if (GIMME_V == G_ARRAY) for (auto message : messages) mXPUSHs(xs::out(message).detach());
    else {
        if (messages.begin() == messages.end()) XSRETURN_UNDEF;
        auto itsv = xs::out(new XSMessageIterator(messages.begin()));
        mPUSHs(itsv.detach());
    }
}

Simple Parser::send_frame (bool final, string payload, int opcode = (int)Opcode::BINARY) {
    auto range = THIS->send_frame(final, payload, (Opcode)opcode);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_frame_av (bool final, Array payload, int opcode = (int)Opcode::BINARY) {
    std::vector<string> list;
    av_to_vstring(aTHX_ payload, list);
    auto range = THIS->send_frame(final, list.begin(), list.end(), (Opcode)opcode);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_control (int opcode, string payload = string()) {
    auto range = THIS->send_control((Opcode)opcode, payload);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_ping (string payload = string()) {
    auto range = THIS->send_ping(payload);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_pong (string payload = string()) {
    auto range = THIS->send_pong(payload);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_close (SV* code = NULL, string message = string()) {
    if (code) {
        auto range = THIS->send_close((uint16_t)SvUV(code), message);
        RETVAL = strings_to_sv(aTHX_ range);
    }
    else RETVAL = xs::out(THIS->send_close());
}

Simple Parser::send_message (string payload, int opcode = (int)Opcode::BINARY) {
    auto range = THIS->send_message(payload, (Opcode)opcode);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_message_av (AV* payload, int opcode = (int)Opcode::BINARY) {
    std::vector<string> list;
    av_to_vstring(aTHX_ payload, list);
    auto range = THIS->send_message(list.begin(), list.end(), (Opcode)opcode);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_message_multiframe (Array payloads, int opcode = (int)Opcode::BINARY) {
    std::vector<std::vector<string>> cont;
    for (const auto& payload : payloads) {
        if (!payload.defined()) continue;
        std::vector<string> tmp;
        tmp.push_back(xs::in<string>(aTHX_ payload));
        cont.push_back(std::move(tmp));
    }
    auto range = THIS->send_message(cont.begin(), cont.end(), (Opcode)opcode);
    RETVAL = strings_to_sv(aTHX_ range);
}

void Parser::reset ()

int Parser::test_parse_frame (string buf) {
    int cnt = 0;
    for (int i = 0; i < 1000; ++i) {
        auto it = THIS->get_frames(buf);
        for (const auto& f : it) cnt++;
    }
    RETVAL = cnt;
}

int Parser::test_send_frame (string pl) {
    int cnt = 0;
    for (int i = 0; i < 1000; ++i) {
        auto range = THIS->send_frame(1, pl);
        for (const string& s : range) cnt += s.length();
    }
    RETVAL = cnt;
}

