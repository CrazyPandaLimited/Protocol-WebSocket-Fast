MODULE = Protocol::WebSocket::XS                PACKAGE = Protocol::WebSocket::XS::Parser
PROTOTYPES: DISABLE

void Parser::configure(Parser::Config config)

size_t Parser::max_frame_size()

size_t Parser::max_message_size()

size_t Parser::max_handshake_size()

Scalar Parser::deflate_config() {
    auto deflate_cfg = THIS->deflate_config();
    if (deflate_cfg) {
        RETVAL = xs::out(deflate_cfg.value());
    }
    else XSRETURN_UNDEF;
}

Scalar Parser::effective_deflate_config() {
    auto deflate_cfg = THIS->effective_deflate_config();
    if (deflate_cfg) {
        RETVAL = xs::out(deflate_cfg.value());
    }
    else XSRETURN_UNDEF;
}

bool Parser::established ()

bool Parser::recv_closed ()

bool Parser::send_closed ()

bool Parser::is_deflate_active ()

void Parser::get_frames (string buf = string()) {
    auto frames = buf ? THIS->get_frames(buf) : THIS->get_frames();
    if (GIMME_V == G_ARRAY) for (auto frame : frames) mXPUSHs(xs::out(frame).detach());
    else {
        if (frames.begin() == frames.end()) XSRETURN_UNDEF;
        auto itsv = xs::out(new XSFrameIterator(frames.begin()));
        mPUSHs(itsv.detach());
    }
}

void Parser::get_messages (string buf = string()) {
    auto messages = buf ? THIS->get_messages(buf) : THIS->get_messages();
    if (GIMME_V == G_ARRAY) for (auto message : messages) mXPUSHs(xs::out(message).detach());
    else {
        if (messages.begin() == messages.end()) XSRETURN_UNDEF;
        auto itsv = xs::out(new XSMessageIterator(messages.begin()));
        mPUSHs(itsv.detach());
    }
}

XSFrameBuilder* Parser::start_message(SV* config = NULL) {
    RETVAL = new XSFrameBuilder(THIS->start_message());
    if (config) {
        Hash settings(config);
        if(settings.exists("deflate")) RETVAL->deflate(SvTRUE(settings.at("deflate")));
        if(settings.exists("final"))   RETVAL->final  (SvTRUE(settings.at("final")));
        if(settings.exists("opcode"))  RETVAL->opcode ((Opcode)SvIV(settings.at("opcode")));
    }
}

Simple Parser::send_control (int opcode, string payload = string()) {
    auto range = THIS->send_control((Opcode)opcode, payload);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_ping (string payload = string()) {
    auto range = THIS->send_ping(payload);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_pong (string payload = string()) {
    auto range = THIS->send_pong(payload);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_close (SV* code = NULL, string message = string()) {
    if (code) {
        auto range = THIS->send_close((uint16_t)SvUV(code), message);
        RETVAL = strings_to_sv(aTHX_ range);
    }
    else RETVAL = xs::out(THIS->send_close());
}

Simple Parser::send_message (Hash settings) {
    auto builder{THIS->message()};
    if(settings.exists("deflate")) builder.deflate(SvTRUE(settings.at("deflate")));
    if(settings.exists("opcode"))  builder.opcode ((Opcode)SvIV(settings.at("opcode")));
    Simple payload = settings.at("payload");
    auto payload_string = payload.as_string();
    auto range = builder.send(payload_string);
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_message_av (Hash settings) {
    auto builder = THIS->message();
    if(settings.exists("deflate")) builder.deflate(SvTRUE(settings.at("deflate")));
    if(settings.exists("opcode"))  builder.opcode ((Opcode)SvIV(settings.at("opcode")));

    Array payload(settings.at("payload"));
    if (!payload) throw "invalid argument (payload must point to array)";

    std::vector<string> list;
    av_to_vstring(aTHX_ payload, list);

    auto range = builder.send(list.begin(), list.end());
    RETVAL = strings_to_sv(aTHX_ range);
}

Simple Parser::send_message_multiframe (Hash settings) {
    auto builder = THIS->message();
    if(settings.exists("deflate")) builder.deflate(SvTRUE(settings.at("deflate")));
    if(settings.exists("opcode"))  builder.opcode ((Opcode)SvIV(settings.at("opcode")));

    Array payloads(settings.at("payload"));
    if (!payloads) throw "invalid argument (payload must point to array)";

    std::vector<std::vector<string>> cont;
    for (const auto& payload : payloads) {
        if (!payload.defined()) continue;
        std::vector<string> tmp;
        tmp.push_back(xs::in<string>(aTHX_ payload));
        cont.push_back(std::move(tmp));
    }

    auto range = builder.send(cont.begin(), cont.end());
    RETVAL = strings_to_sv(aTHX_ range);
}

void Parser::reset ()

void Parser::no_deflate()

int Parser::test_parse_frame (string buf) {
    int cnt = 0;
    for (int i = 0; i < 1000; ++i) {
        auto it = THIS->get_frames(buf);
        for (const auto& f : it) cnt++;
    }
    RETVAL = cnt;
}

int Parser::test_send_frame (string pl) {
    int cnt = 0;
    for (int i = 0; i < 1000; ++i) {
        auto range = THIS->start_message().final(true).send(pl);
        for (const string& s : range) cnt += s.length();
    }
    RETVAL = cnt;
}

